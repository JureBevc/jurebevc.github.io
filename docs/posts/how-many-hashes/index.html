<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hashlookup - A reverse lookup table tool | Jure Bevc</title><meta name=keywords content="Go,Data,Databases,Cryptography"><meta name=description content="Introduction Reverse hash lookup tables are data structures used to quicken the process of finding plaintext values corresponding to given hash values. Hash functions are designed to convert input data into fixed-length hash codes, making it challenging (impossible) to reverse-engineer the original input from the hash alone.
Reverse hash lookup tables work by precomputing and storing pairs of plaintext and corresponding hash values. This allows for efficient and rapid identification of plaintext inputs when given a hash value, making them a valuable tool for attackers attempting to crack hashed passwords and a subject of interest for defenders seeking to enhance security measures by mitigating this type of vulnerability."><meta name=author content="Me"><link rel=canonical href=https://jurebevc.com/posts/how-many-hashes/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jurebevc.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://jurebevc.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://jurebevc.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://jurebevc.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://jurebevc.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="hashlookup - A reverse lookup table tool"><meta property="og:description" content="Introduction Reverse hash lookup tables are data structures used to quicken the process of finding plaintext values corresponding to given hash values. Hash functions are designed to convert input data into fixed-length hash codes, making it challenging (impossible) to reverse-engineer the original input from the hash alone.
Reverse hash lookup tables work by precomputing and storing pairs of plaintext and corresponding hash values. This allows for efficient and rapid identification of plaintext inputs when given a hash value, making them a valuable tool for attackers attempting to crack hashed passwords and a subject of interest for defenders seeking to enhance security measures by mitigating this type of vulnerability."><meta property="og:type" content="article"><meta property="og:url" content="https://jurebevc.com/posts/how-many-hashes/"><meta property="og:image" content="https://jurebevc.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-03T21:14:30+02:00"><meta property="article:modified_time" content="2023-09-03T21:14:30+02:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jurebevc.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="hashlookup - A reverse lookup table tool"><meta name=twitter:description content="Introduction Reverse hash lookup tables are data structures used to quicken the process of finding plaintext values corresponding to given hash values. Hash functions are designed to convert input data into fixed-length hash codes, making it challenging (impossible) to reverse-engineer the original input from the hash alone.
Reverse hash lookup tables work by precomputing and storing pairs of plaintext and corresponding hash values. This allows for efficient and rapid identification of plaintext inputs when given a hash value, making them a valuable tool for attackers attempting to crack hashed passwords and a subject of interest for defenders seeking to enhance security measures by mitigating this type of vulnerability."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jurebevc.com/posts/"},{"@type":"ListItem","position":2,"name":"hashlookup - A reverse lookup table tool","item":"https://jurebevc.com/posts/how-many-hashes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"hashlookup - A reverse lookup table tool","name":"hashlookup - A reverse lookup table tool","description":"Introduction Reverse hash lookup tables are data structures used to quicken the process of finding plaintext values corresponding to given hash values. Hash functions are designed to convert input data into fixed-length hash codes, making it challenging (impossible) to reverse-engineer the original input from the hash alone.\nReverse hash lookup tables work by precomputing and storing pairs of plaintext and corresponding hash values. This allows for efficient and rapid identification of plaintext inputs when given a hash value, making them a valuable tool for attackers attempting to crack hashed passwords and a subject of interest for defenders seeking to enhance security measures by mitigating this type of vulnerability.","keywords":["Go","Data","Databases","Cryptography"],"articleBody":"Introduction Reverse hash lookup tables are data structures used to quicken the process of finding plaintext values corresponding to given hash values. Hash functions are designed to convert input data into fixed-length hash codes, making it challenging (impossible) to reverse-engineer the original input from the hash alone.\nReverse hash lookup tables work by precomputing and storing pairs of plaintext and corresponding hash values. This allows for efficient and rapid identification of plaintext inputs when given a hash value, making them a valuable tool for attackers attempting to crack hashed passwords and a subject of interest for defenders seeking to enhance security measures by mitigating this type of vulnerability.\nThe tool The goal was to create a CLI tool for producing a reverse hash lookup table. It is intended to be simple and effective to use and allow anyone to generate a reverse lookup table of arbitrary size.\nI’ve written this tool in Go, but requires the user to set up a local or remote PostgreSQL server themselves. The fastest way to do this is to run the postgres docker image. All code is available on GitHub.\nThe tool supports two ways to create and query your tables - simple or rainbow tables.\nSimple lookup tables It is trivial to create the most basic version of a reverse lookup table, but that doesn’t lessen their effectiveness. These tables simply store all provided passwords and their hashes. Running the following command will generate the table:\nhashlookup.exe create-lookup -alg [algorithm] -file [filepath] To populate this table we loop through all passwords in the file, calculate the hash and add it to the database:\nAfter the table is generated you can query the data:\nhashlookup.exe check-lookup -alg [algorithm] -hash [hash] Rainbow tables Generating rainbow tables is a more resource-intensive process. It involves hashing candidate passwords and then applying hash chain reduction functions to minimize storage requirements.\nA single node in this chain can be represented by two functions called back to back. The input to the node is a potential password x, which gets passed to a hashing function and the output of the hashing h is then sent as a parameter to the reduction function, along with the index i of the node in the chain. The output of the reduction function is another potential password y, which can then serve as an input to the next node. Here’s a visual example of a node:\nThe main benefit of chaining these nodes is that we can store only the input to the first node and the result of the last node. To check if a hash exists in the rainbow table we construct a chain starting with the given hash and check if any of the node outputs match a record in our database. If so, we can reconstruct the chain from the chain inputs stored in our database and find which password in the chain belongs to the given hash. A single chain can therefore cover a larger amount of hashes, while only requiring us to store two values in the database.\nThe main issue in generating rainbow tables are collisions. Meaning that our reduction function can generate the same result for different hashes. This results in repeated nodes in the chain. Collisions tend to happen when a reduction function generates too few characters to properly spread out different hashes. Knowing this I decided to minimize these collisions by forcing the reduction functions to start the chain with longer strings and produce shorter strings towards the end.\nThe length of the string was decided by the reduction function input parameter i and was clamped between common password length extremes. This resulted in fewer collisions, since they occured only towards the end of the chain. Here’s a visual example of a collision using this approach:\nHere’s a simple implementation of the reduction function that proved to be effective enough in producing fewer collisions: Creating a rainbow table with this tool is as straightforward as creating the simple lookup table:\nhashlookup.exe create-rainbow -alg [algorithm] -file [filepath] After the table is generated you can query the data:\nhashlookup.exe check-rainbow -alg [algorithm] -hash [hash] Performance The tool was tested on a publicly available dataset of 10 million passwords and the SHA-256 algorithm. The simple lookup table required no additional parameters, while the rainbow table requires us to decide on the chain length, which was set to 1000 in this test.\nTime: Generating the simple lookup table took around 25 minutes, while the rainbow table took a little under 8 hours.\nSpace: When compared in regards to disk space, the simple lookup table ended up with 817MB and the rainbow table with 578MB. Both tables were created using the same number of passwords, so this difference comes from the fact that all passwords mapped into smaller string in the rainbow table compared to the length of the entire SHA-256 hash that is stored for the simple table.\nIt goes without saying that querying the rainbow table also takes longer, but no intensive tests or comparisons were made so far.\nConclusion This was fun. Salt your passwords.\n","wordCount":"849","inLanguage":"en","datePublished":"2023-09-03T21:14:30+02:00","dateModified":"2023-09-03T21:14:30+02:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jurebevc.com/posts/how-many-hashes/"},"publisher":{"@type":"Organization","name":"Jure Bevc","logo":{"@type":"ImageObject","url":"https://jurebevc.com/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jurebevc.com/ accesskey=h title="  (Alt + H)"><img src=https://jurebevc.com/apple-touch-icon.png alt aria-label=logo height=35></a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jurebevc.com/>Home</a>&nbsp;»&nbsp;<a href=https://jurebevc.com/posts/>Posts</a></div><h1 class=post-title>hashlookup - A reverse lookup table tool</h1><div class=post-meta><span title='2023-09-03 21:14:30 +0200 CEST'>September 3, 2023</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;849 words</div></header><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>Reverse hash lookup tables are data structures used to quicken the process of finding plaintext values corresponding to given hash values. Hash functions are designed to convert input data into fixed-length hash codes, making it challenging (impossible) to reverse-engineer the original input from the hash alone.</p><p>Reverse hash lookup tables work by precomputing and storing pairs of plaintext and corresponding hash values. This allows for efficient and rapid identification of plaintext inputs when given a hash value, making them a valuable tool for attackers attempting to crack hashed passwords and a subject of interest for defenders seeking to enhance security measures by mitigating this type of vulnerability.</p><h2 id=the-tool>The tool<a hidden class=anchor aria-hidden=true href=#the-tool>#</a></h2><p>The goal was to create a CLI tool for producing a reverse hash lookup table. It is intended to be simple and effective to use and allow anyone to generate a reverse lookup table of arbitrary size.</p><p>I&rsquo;ve written this tool in Go, but requires the user to set up a local or remote PostgreSQL server themselves. The fastest way to do this is to run the <a href=https://hub.docker.com/_/postgres>postgres docker image</a>. All code is available on <a href=https://www.github.com/JureBevc/hashlookup>GitHub</a>.</p><p>The tool supports two ways to create and query your tables - simple or rainbow tables.</p><h2 id=simple-lookup-tables>Simple lookup tables<a hidden class=anchor aria-hidden=true href=#simple-lookup-tables>#</a></h2><p>It is trivial to create the most basic version of a reverse lookup table, but that doesn&rsquo;t lessen their effectiveness. These tables simply store all provided passwords and their hashes. Running the following command will generate the table:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>hashlookup.exe create-lookup -alg <span class=o>[</span>algorithm<span class=o>]</span> -file <span class=o>[</span>filepath<span class=o>]</span>
</span></span></code></pre></div><p>To populate this table we loop through all passwords in the file, calculate the hash and add it to the database:</p><p><img loading=lazy src=/hashlookup-code1.png alt="Alt text"></p><p>After the table is generated you can query the data:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>hashlookup.exe check-lookup -alg <span class=o>[</span>algorithm<span class=o>]</span> -hash <span class=o>[</span>hash<span class=o>]</span>
</span></span></code></pre></div><h2 id=rainbow-tables>Rainbow tables<a hidden class=anchor aria-hidden=true href=#rainbow-tables>#</a></h2><p>Generating rainbow tables is a more resource-intensive process. It involves hashing candidate passwords and then applying hash chain reduction functions to minimize storage requirements.</p><p>A single node in this chain can be represented by two functions called back to back. The input to the node is a potential password <code>x</code>, which gets passed to a hashing function and the output of the hashing <code>h</code> is then sent as a parameter to the reduction function, along with the index <code>i</code> of the node in the chain. The output of the reduction function is another potential password <code>y</code>, which can then serve as an input to the next node. Here&rsquo;s a visual example of a node:</p><p><img loading=lazy src=/rainbow-table-node.png alt="Alt text"></p><p>The main benefit of chaining these nodes is that we can store only the input to the first node and the result of the last node. To check if a hash exists in the rainbow table we construct a chain starting with the given hash and check if any of the node outputs match a record in our database. If so, we can reconstruct the chain from the chain inputs stored in our database and find which password in the chain belongs to the given hash. A single chain can therefore cover a larger amount of hashes, while only requiring us to store two values in the database.</p><p>The main issue in generating rainbow tables are collisions. Meaning that our reduction function can generate the same result for different hashes. This results in repeated nodes in the chain. Collisions tend to happen when a reduction function generates too few characters to properly spread out different hashes. Knowing this I decided to minimize these collisions by forcing the reduction functions to start the chain with longer strings and produce shorter strings towards the end.</p><p>The length of the string was decided by the reduction function input parameter <code>i</code> and was clamped between common password length extremes. This resulted in fewer collisions, since they occured only towards the end of the chain. Here&rsquo;s a visual example of a collision using this approach:</p><p><img loading=lazy src=/rainbow-collisions.png alt="Alt text"></p><p>Here&rsquo;s a simple implementation of the reduction function that proved to be effective enough in producing fewer collisions:
<img loading=lazy src=/hashlookup-code2.png alt="Alt text"></p><p>Creating a rainbow table with this tool is as straightforward as creating the simple lookup table:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>hashlookup.exe create-rainbow -alg <span class=o>[</span>algorithm<span class=o>]</span> -file <span class=o>[</span>filepath<span class=o>]</span>
</span></span></code></pre></div><p>After the table is generated you can query the data:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>hashlookup.exe check-rainbow -alg <span class=o>[</span>algorithm<span class=o>]</span> -hash <span class=o>[</span>hash<span class=o>]</span>
</span></span></code></pre></div><h2 id=performance>Performance<a hidden class=anchor aria-hidden=true href=#performance>#</a></h2><p>The tool was tested on a publicly available dataset of 10 million passwords and the SHA-256 algorithm. The simple lookup table required no additional parameters, while the rainbow table requires us to decide on the chain length, which was set to 1000 in this test.</p><p>Time: Generating the simple lookup table took around 25 minutes, while the rainbow table took a little under 8 hours.</p><p>Space: When compared in regards to disk space, the simple lookup table ended up with 817MB and the rainbow table with 578MB. Both tables were created using the same number of passwords, so this difference comes from the fact that all passwords mapped into smaller string in the rainbow table compared to the length of the entire SHA-256 hash that is stored for the simple table.</p><p>It goes without saying that querying the rainbow table also takes longer, but no intensive tests or comparisons were made so far.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>This was fun. Salt your passwords.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://jurebevc.com/tags/go/>Go</a></li><li><a href=https://jurebevc.com/tags/data/>Data</a></li><li><a href=https://jurebevc.com/tags/databases/>Databases</a></li><li><a href=https://jurebevc.com/tags/cryptography/>Cryptography</a></li></ul><nav class=paginav><a class=prev href=https://jurebevc.com/posts/cyanic-deployment-tool/><span class=title>« Prev</span><br><span>Cyanic - A blue/green deployment tool</span></a>
<a class=next href=https://jurebevc.com/posts/reading-memory-during-runtime/><span class=title>Next »</span><br><span>Reading memory during runtime</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>