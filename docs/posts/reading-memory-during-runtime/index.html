<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Reading memory during runtime | Jure Bevc</title><meta name=keywords content="Python,Memory"><meta name=description content="What and why Lately, I&rsquo;ve been curious about reading the memory of a process during runtime. There are several use cases for this, but the ones that piqued my interest are anti-virus software and (illegal) botting software for video games. Game companies can invest a lot of resources into solving botting issues, but consistently detecting programs that read your game&rsquo;s memory can be very difficult if the programs are not injecting anything directly into your running process."><meta name=author content="Me"><link rel=canonical href=https://jurebevc.github.io/posts/reading-memory-during-runtime/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.5c25c975546c048d1a5600aadb48425ae1bc921a9a18fe67d6955c9535260811.css integrity="sha256-XCXJdVRsBI0aVgCq20hCWuG8khqaGP5n1pVclTUmCBE=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jurebevc.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://jurebevc.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://jurebevc.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://jurebevc.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://jurebevc.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Reading memory during runtime"><meta property="og:description" content="What and why Lately, I&rsquo;ve been curious about reading the memory of a process during runtime. There are several use cases for this, but the ones that piqued my interest are anti-virus software and (illegal) botting software for video games. Game companies can invest a lot of resources into solving botting issues, but consistently detecting programs that read your game&rsquo;s memory can be very difficult if the programs are not injecting anything directly into your running process."><meta property="og:type" content="article"><meta property="og:url" content="https://jurebevc.github.io/posts/reading-memory-during-runtime/"><meta property="og:image" content="https://jurebevc.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-19T12:36:58+02:00"><meta property="article:modified_time" content="2023-08-19T12:36:58+02:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jurebevc.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Reading memory during runtime"><meta name=twitter:description content="What and why Lately, I&rsquo;ve been curious about reading the memory of a process during runtime. There are several use cases for this, but the ones that piqued my interest are anti-virus software and (illegal) botting software for video games. Game companies can invest a lot of resources into solving botting issues, but consistently detecting programs that read your game&rsquo;s memory can be very difficult if the programs are not injecting anything directly into your running process."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jurebevc.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Reading memory during runtime","item":"https://jurebevc.github.io/posts/reading-memory-during-runtime/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Reading memory during runtime","name":"Reading memory during runtime","description":"What and why Lately, I\u0026rsquo;ve been curious about reading the memory of a process during runtime. There are several use cases for this, but the ones that piqued my interest are anti-virus software and (illegal) botting software for video games. Game companies can invest a lot of resources into solving botting issues, but consistently detecting programs that read your game\u0026rsquo;s memory can be very difficult if the programs are not injecting anything directly into your running process.","keywords":["Python","Memory"],"articleBody":"What and why Lately, I’ve been curious about reading the memory of a process during runtime. There are several use cases for this, but the ones that piqued my interest are anti-virus software and (illegal) botting software for video games. Game companies can invest a lot of resources into solving botting issues, but consistently detecting programs that read your game’s memory can be very difficult if the programs are not injecting anything directly into your running process.\nThe example I’m showing here is about reading a potential “health” or “hit points” value from a game’s process memory.\nThe problem So here’s the main idea: We want to read the memory of any process currently running on our machine, without injecting our own code into it.\nTo do this, we have to solve two main problems regarding the data we’re interested in:\nFind where the current process has stored the data in the memory.\nFind out how the memory location of the data changes when the process is restarted.\nFinding the data of interest Once the process you’re interested in is up and running, finding the current address of the desired data is relatively simple. Cheat Engine is a great (and free) tool for this job. For example, searching for your “hit points” data can be as simple as looking at your value in-game and scanner for the value in Cheat Engine:\nThere are many different values that can match the once you’re scanning for, but if you change the value in-game and scan again, the remaing list of possible addresses will get smaller and smaller. Once you have only one address left that changes accordingly, you found the address you’re looking for.\nSo it seems we have what we need and we’re done? Well, this solution only covers the first problem mentioned at the beginning - finding the current process has stored the data. But once a process is restarted there is no guarantee that the value will be stored in the exact same memory address.\nPointer offsets So how can we keep track of values in the process memory, even if the process is restarted? A trivial solution would be to simply repeat the manual search again, keeping track of the changing values and scanning until we found our address again. But this is out of the question, if we want to write a tool that we deliver to other users.\nCheat Engine can help us here as well. In Cheat Engine, comparing pointermaps is a technique used to identify static memory addresses in a program, even when the program’s base address changes due to updates or restarts. Pointermaps are an essential part of the process when working with dynamic memory addresses. There are several good guides and videos that go into depth explaining how to create and compare pointermaps, but in this case it’s only important to keep in mind the result that this technique brings us.\nThe result of comparing pointermaps is that we’re no longer dealing with memory addresses directly, but with pointers that lead us to the final memory address. These pointer paths are given by so-called offsets, which we can then use to track our desired data, no matter how many times the process is restarted. Here’s how these pointer offsets look like when scanning for a particular memory address:\nAs you can see, there are many pointer offsets that can match a given memory address, that is why we compare multiple pointer scans, until we find a set of offsets that work for our use-case.\nThis approach requires us to do one extra step in our program, where we calculate the actual address with pointer offsets, so that we can read the address later. This is an example in Python using the Pymem module:\nUsing the address Once we have calculated the desired address, reading the actual value with Pymem is simple:\nThis example demonstrates reading an integer value from memory, but the approach extends to other data types and larger memory portions, such as data structures like lists, maps, and trees.\n","wordCount":"679","inLanguage":"en","datePublished":"2023-08-19T12:36:58+02:00","dateModified":"2023-08-19T12:36:58+02:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jurebevc.github.io/posts/reading-memory-during-runtime/"},"publisher":{"@type":"Organization","name":"Jure Bevc","logo":{"@type":"ImageObject","url":"https://jurebevc.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jurebevc.github.io/ accesskey=h title="  (Alt + H)"><img src=https://jurebevc.github.io/apple-touch-icon.png alt aria-label=logo height=35></a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jurebevc.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://jurebevc.github.io/posts/>Posts</a></div><h1 class=post-title>Reading memory during runtime</h1><div class=post-meta><span title='2023-08-19 12:36:58 +0200 CEST'>August 19, 2023</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;679 words</div></header><div class=post-content><h2 id=what-and-why>What and why<a hidden class=anchor aria-hidden=true href=#what-and-why>#</a></h2><p>Lately, I&rsquo;ve been curious about reading the memory of a process during runtime. There are several use cases for this, but the ones that piqued my interest are anti-virus software and (illegal) botting software for video games. Game companies can invest a lot of resources into solving botting issues, but consistently detecting programs that read your game&rsquo;s memory can be very difficult if the programs are not injecting anything directly into your running process.</p><p>The example I&rsquo;m showing here is about reading a potential &ldquo;health&rdquo; or &ldquo;hit points&rdquo; value from a game&rsquo;s process memory.</p><h2 id=the-problem>The problem<a hidden class=anchor aria-hidden=true href=#the-problem>#</a></h2><p>So here&rsquo;s the main idea: <em>We want to read the memory of any process currently running on our machine, without injecting our own code into it.</em></p><p>To do this, we have to solve two main problems regarding the data we&rsquo;re interested in:</p><ol><li><p>Find where the current process has stored the data in the memory.</p></li><li><p>Find out how the memory location of the data changes when the process is restarted.</p></li></ol><h2 id=finding-the-data-of-interest>Finding the data of interest<a hidden class=anchor aria-hidden=true href=#finding-the-data-of-interest>#</a></h2><p>Once the process you&rsquo;re interested in is up and running, finding the current address of the desired data is relatively simple. <a href=https://www.cheatengine.org/>Cheat Engine</a> is a great (and free) tool for this job. For example, searching for your &ldquo;hit points&rdquo; data can be as simple as looking at your value in-game and scanner for the value in Cheat Engine:</p><p><img loading=lazy src=/cheat-engine-scan.png alt="Alt text"></p><p>There are many different values that can match the once you&rsquo;re scanning for, but if you change the value in-game and scan again, the remaing list of possible addresses will get smaller and smaller. Once you have only one address left that changes accordingly, you found the address you&rsquo;re looking for.</p><p>So it seems we have what we need and we&rsquo;re done? Well, this solution only covers the first problem mentioned at the beginning - finding the <em>current</em> process has stored the data. But once a process is restarted there is no guarantee that the value will be stored in the exact same memory address.</p><h2 id=pointer-offsets>Pointer offsets<a hidden class=anchor aria-hidden=true href=#pointer-offsets>#</a></h2><p>So how can we keep track of values in the process memory, even if the process is restarted? A trivial solution would be to simply repeat the manual search again, keeping track of the changing values and scanning until we found our address again. But this is out of the question, if we want to write a tool that we deliver to other users.</p><p>Cheat Engine can help us here as well. In Cheat Engine, comparing pointermaps is a technique used to identify static memory addresses in a program, even when the program&rsquo;s base address changes due to updates or restarts. Pointermaps are an essential part of the process when working with dynamic memory addresses. There are several good guides and videos that go into depth explaining how to create and compare pointermaps, but in this case it&rsquo;s only important to keep in mind the result that this technique brings us.</p><p>The result of comparing pointermaps is that we&rsquo;re no longer dealing with memory addresses directly, but with pointers that lead us to the final memory address. These pointer paths are given by so-called offsets, which we can then use to track our desired data, no matter how many times the process is restarted. Here&rsquo;s how these pointer offsets look like when scanning for a particular memory address:</p><p><img loading=lazy src=/pointer-scan.png alt="Alt text"></p><p>As you can see, there are many pointer offsets that can match a given memory address, that is why we compare multiple pointer scans, until we find a set of offsets that work for our use-case.</p><p>This approach requires us to do one extra step in our program, where we calculate the actual address with pointer offsets, so that we can read the address later. This is an example in Python using the <a href=https://github.com/srounet/Pymem>Pymem</a> module:</p><p><img loading=lazy src=/calculate-address.png alt="Image alt"></p><h2 id=using-the-address>Using the address<a hidden class=anchor aria-hidden=true href=#using-the-address>#</a></h2><p>Once we have calculated the desired address, reading the actual value with Pymem is simple:</p><p><img loading=lazy src=/read-memory.png alt="Image alt"></p><p>This example demonstrates reading an integer value from memory, but the approach extends to other data types and larger memory portions, such as data structures like lists, maps, and trees.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://jurebevc.github.io/tags/python/>Python</a></li><li><a href=https://jurebevc.github.io/tags/memory/>Memory</a></li></ul><nav class=paginav><a class=prev href=https://jurebevc.github.io/posts/how-many-hashes/><span class=title>« Prev</span><br><span>hashlookup - A reverse lookup table tool</span></a>
<a class=next href=https://jurebevc.github.io/posts/map-share/><span class=title>Next »</span><br><span>Map share</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>